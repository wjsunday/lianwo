'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = virtualize;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactAddonsShallowCompare = require('react-addons-shallow-compare');

var _reactAddonsShallowCompare2 = _interopRequireDefault(_reactAddonsShallowCompare);

var _mod = require('./utils/mod');

var _mod2 = _interopRequireDefault(_mod);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Render one more slide for going backward as it's more difficult to
// keep the window up to date.
var LEFT_OFFSET = 1; //  weak

function virtualize(MyComponent) {
  var Virtualize = function (_Component) {
    (0, _inherits3.default)(Virtualize, _Component);

    function Virtualize() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3.default)(this, Virtualize);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Virtualize.__proto__ || (0, _getPrototypeOf2.default)(Virtualize)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.timer = null, _this.handleChangeIndex = function (indexContainer, indexLatest) {
        var _this$props = _this.props,
            slideCount = _this$props.slideCount,
            onChangeIndex = _this$props.onChangeIndex;


        var indexDiff = indexContainer - indexLatest;
        var index = _this.state.index + indexDiff;

        if (slideCount) {
          index = (0, _mod2.default)(index, slideCount);
        }

        if (onChangeIndex) {
          onChangeIndex(index, _this.state.index);
        } else {
          _this.setIndex(index, indexContainer, indexDiff);
        }
      }, _this.handleTransitionEnd = function () {
        // Delay the update of the window to fix an issue with react-motion.
        _this.timer = setTimeout(function () {
          _this.setWindow();
        }, 0);

        if (_this.props.onTransitionEnd) {
          _this.props.onTransitionEnd();
        }
      }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
    }

    /**
     *
     *           index          indexStop
     *             |              |
     * indexStart  |       indexContainer
     *   |         |         |    |
     * ------------|-------------------------->
     *  -2    -1   0    1    2    3    4    5
     */


    (0, _createClass3.default)(Virtualize, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.setState({
          index: this.props.index,
          indexContainer: this.props.overscanSlideCount
        });

        this.setWindow(this.props);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var index = nextProps.index;


        if (typeof index === 'number' && index !== this.props.index) {
          var indexDiff = index - this.props.index;
          this.setIndex(index, this.state.indexContainer + indexDiff, indexDiff);
        }
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate(nextProps, nextState) {
        return (0, _reactAddonsShallowCompare2.default)(this, nextProps, nextState);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        clearInterval(this.timer);
      }
    }, {
      key: 'setIndex',
      value: function setIndex(index, indexContainer, indexDiff) {
        var nextState = {
          index: index,
          indexContainer: indexContainer,
          indexStart: this.state.indexStart,
          indexStop: this.state.indexStop
        };

        // We are going forward, let's render one more slide ahead.
        if (indexDiff > 0 && (!this.props.slideCount || nextState.indexStop < this.props.slideCount - 1)) {
          nextState.indexStop += 1;
        }

        // Extend the bounds if needed.
        if (index > nextState.indexStop) {
          nextState.indexStop = index;
        }

        var leftAhead = nextState.indexStart - index;

        // Extend the bounds if needed.
        if (leftAhead > 0) {
          nextState.indexContainer += leftAhead;
          nextState.indexStart -= leftAhead;
        }

        this.setState(nextState);
      }
    }, {
      key: 'setWindow',
      value: function setWindow() {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state;
        var slideCount = this.props.slideCount;


        var index = state.index;
        var leftAhead = this.props.overscanSlideCount + LEFT_OFFSET;
        var rightAhead = this.props.overscanSlideCount;

        if (slideCount) {
          if (leftAhead > index) {
            leftAhead = index;
          }

          if (rightAhead + index > slideCount - 1) {
            rightAhead = slideCount - index - 1;
          }
        }

        this.setState({
          indexContainer: leftAhead,
          indexStart: index - leftAhead,
          indexStop: index + rightAhead
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            children = _props.children,
            indexProp = _props.index,
            onChangeIndex = _props.onChangeIndex,
            overscanSlideCount = _props.overscanSlideCount,
            slideCount = _props.slideCount,
            slideRenderer = _props.slideRenderer,
            other = (0, _objectWithoutProperties3.default)(_props, ['children', 'index', 'onChangeIndex', 'overscanSlideCount', 'slideCount', 'slideRenderer']);
        var _state = this.state,
            indexContainer = _state.indexContainer,
            indexStart = _state.indexStart,
            indexStop = _state.indexStop;


        var slides = [];

        for (var slideIndex = indexStart; slideIndex <= indexStop; slideIndex += 1) {
          slides.push(slideRenderer({
            index: slideIndex,
            key: slideIndex
          }));
        }

        return _react2.default.createElement(
          MyComponent,
          (0, _extends3.default)({
            index: indexContainer,
            onChangeIndex: this.handleChangeIndex,
            onTransitionEnd: this.handleTransitionEnd
          }, other),
          slides
        );
      }
    }]);
    return Virtualize;
  }(_react.Component);

  Virtualize.defaultProps = {
    index: 0,
    overscanSlideCount: 2
  };
  process.env.NODE_ENV !== "production" ? Virtualize.propTypes = {
    /**
     * @ignore
     */
    children: function children(props, propName) {
      if (props[propName] !== undefined) {
        return new Error("The children property isn't supported.");
      }

      return null;
    },
    /**
     * @ignore
     */
    index: _react.PropTypes.number,
    /**
     * @ignore
     */
    onChangeIndex: _react.PropTypes.func,
    /**
     * @ignore
     */
    onTransitionEnd: _react.PropTypes.func,
    /**
     * Number of slide to render before/after the visible slide.
     */
    overscanSlideCount: _react.PropTypes.number,
    /**
     * When set, it's adding a limit to the number of slide: [0, slideCount].
     */
    slideCount: _react.PropTypes.number,
    /**
     * Responsible for rendering a slide given an index.
     * ({ index: number }): node.
     */
    slideRenderer: _react.PropTypes.func.isRequired
  } : void 0;


  return Virtualize;
}